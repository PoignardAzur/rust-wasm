use script::*;
use rust_wasm::values::Value;
use std::str::FromStr;
use std::{f32, f64};

grammar;

pub script: Script = cmd*;

cmd: Cmd = {
	module => Cmd::Module(<>),
	action => Cmd::Action(<>),
	assertion => Cmd::Assertion(<>),
	"(" "register" <n:string> <m:name?> ")" => Cmd::Register { name: n.to_owned(), module: m.map(|s| s.to_owned()) },
};

module: Module = {
	"(" "module" <n:name?> "binary" <bss:bytestring*> ")" => Module::Binary(n.map(|s| s.to_owned()), bss.concat()),
	"(" "module" <n:name?> "quote" <ss:string*> ")" => Module::Text(n.map(|s| s.to_owned()), ss.concat()),
};

name: &'input str = <s:r"\$[\w_]+"> => &s[1..];

//bytestring: Vec<u8> = <s:r#""(\\[[:xdigit:]]{2})*""#> => {
bytestring: Vec<u8> = <s:string> => {
	let ascii_to_byte = |v| { char::from(v).to_digit(16).unwrap() as u8 };
	s.as_bytes().chunks(3).map(|c| 16 * ascii_to_byte(c[1]) + ascii_to_byte(c[2])).collect()
};

assertion: Assertion = "(" <assertion_int> ")";

assertion_int: Assertion = {
	"assert_return" <a:action> <rs:expr*> => Assertion::Return(a, rs),
	"assert_return_canonical_nan" <a:action> => Assertion::ReturnCanonicalNan(a),
	"assert_return_arithmetic_nan" <a:action> => Assertion::ReturnArithmeticNan(a),
	"assert_trap" <a:action> <s:string> => Assertion::TrapAction(a, s.to_owned()),
	"assert_trap" <m:module> <s:string> => Assertion::TrapInstantiate(m, s.to_owned()),
	"assert_exhaustion" <a:action> <s:string> => Assertion::Exhaustion(a, s.to_owned()),
	"assert_invalid" <m:module> <s:string> => Assertion::Invalid(m, s.to_owned()),
	"assert_malformed" <m:module> <s:string> => Assertion::Malformed(m, s.to_owned()),
	"assert_unlinkable" <m:module> <s:string> => Assertion::Unlinkable(m, s.to_owned()),
};

action: Action = {
	"(" "invoke" <m:name?> <f:string> <args:expr*> ")" => Action::Invoke {
		module: m.map(|s| s.to_owned()),
		func: f.to_owned(),
		args: args
	},
	"(" "get" <m:name?> <n:string> ")" => Action::Get { module: m.map(|s| s.to_owned()), global: n.to_owned() },
};

expr: Value = "(" <expr_int> ")";

expr_int: Value = {
	"i32.const" <v:int> => Value::I32(v as u32),
	"i64.const" <v:int> => Value::I64(v as u64),
	"f32.const" <v:float32> => Value::F32(v as f32),
	"f64.const" <v:float64> => Value::F64(v as f64),
};

int: i64 = <s:r"[+-]?\d+"> => i64::from_str(s).unwrap();

float32: f32 = {
	<s:r"[+-]?\d+((\.\d*)?[eE][+-]?\d+|\.\d*)"> => f32::from_str(s).unwrap(),
	"-inf" => f32::NEG_INFINITY,
	r"\+?inf" => f32::INFINITY,
	<sign:r"[+-]"?> "nan:" <p:r"0x[[:xdigit:]]+"> => {
		let z = f32::from_bits(f32::INFINITY.to_bits() | u32::from_str_radix(&p[2..], 16).unwrap());
		if let Some("-") = sign { -z } else { z }
	},
};

float64: f64 = {
	<s:r"[+-]?\d+((\.\d*)?[eE][+-]?\d+|\.\d*)"> => f64::from_str(s).unwrap(),
	"-inf" => f64::NEG_INFINITY,
	r"\+?inf" => f64::INFINITY,
	<sign:r"[+-]"?> "nan:" <p:r"0x[[:xdigit:]]+"> => {
		let z = f64::from_bits(f64::INFINITY.to_bits() | u64::from_str_radix(&p[2..], 16).unwrap());
		if let Some("-") = sign { -z } else { z }
	},
};

string: &'input str = <s:r#""([^"\\]|\\([tnr\\"]|[[:xdigit:]]{2}|u\{[[:xdigit:]]+\}))*""#> => &s[1..s.len()-1];
