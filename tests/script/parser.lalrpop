use script::*;
use rust_wasm::values::Value;
use std::str::FromStr;
use std::{f32, f64};
use hexf_parse::{parse_hexf32, parse_hexf64};

//! This grammar does not match exactly the one given informally in the
//! official interpreter implementation, but it is good enough to parse the test
//! scripts converted into binary.

grammar;

pub script: Script = cmd*;

cmd: Cmd = {
	module => Cmd::ModuleSource(<>),
	action => Cmd::Action(<>),
	assertion => Cmd::Assertion(<>),
	"(" "register" <n:string> <m:name?> ")" => Cmd::Register { name: n, mod_ref: m },
};

module: ModuleSource = {
	"(" "module" <n:name?> "binary" <bss:bytestring*> ")" => ModuleSource::Binary(n, bss.concat()),
	"(" "module" <n:name?> "quote" <ss:string*> ")" => ModuleSource::Text(n, ss.concat()),
};

name: String = <s:r"\$[\w_]+"> => String::from_str(&s[1..]).unwrap();

assertion: Assertion = "(" <assertion_int> ")";

assertion_int: Assertion = {
	"assert_return" <a:action> <rs:expr*> => Assertion::Return(a, rs),
	"assert_return_canonical_nan" <a:action> => Assertion::ReturnCanonicalNan(a),
	"assert_return_arithmetic_nan" <a:action> => Assertion::ReturnArithmeticNan(a),
	"assert_trap" <a:action> <s:string> => Assertion::TrapAction(a, s),
	"assert_trap" <m:module> <s:string> => Assertion::TrapInstantiate(m, s),
	"assert_exhaustion" <a:action> <s:string> => Assertion::Exhaustion(a, s),
	"assert_invalid" <m:module> <s:string> => Assertion::Invalid(m, s),
	"assert_malformed" <m:module> <s:string> => Assertion::Malformed(m, s),
	"assert_unlinkable" <m:module> <s:string> => Assertion::Unlinkable(m, s),
};

action: Action = {
	"(" "invoke" <m:name?> <f:string> <args:expr*> ")" => Action::Invoke {
		mod_ref: m.map(|s| s),
		func: f,
		args: args
	},
	"(" "get" <m:name?> <n:string> ")" => Action::Get { mod_ref: m, global: n },
};

expr: Value = "(" <expr_int> ")";

expr_int: Value = {
	"i32.const" <v:int> => Value::I32(v as u32),
	"i64.const" <v:int> => Value::I64(v as u64),
	"f32.const" <v:float32> => Value::F32(v as f32),
	"f64.const" <v:float64> => Value::F64(v as f64),
};

int: i64 = <s:r"[+-]?\d+"> => i64::from_str(s).unwrap();

float32: f32 = {
	"-inf" => f32::NEG_INFINITY,
	r"\+?inf" => f32::INFINITY,
	<sign:r"[+-]"?> "nan:" <p:r"0x[[:xdigit:]]+"> => {
		let z = f32::from_bits(f32::INFINITY.to_bits() | u32::from_str_radix(&p[2..], 16).unwrap());
		if let Some("-") = sign { -z } else { z }
	},
	<s:r"[+-]?0x[[:xdigit:]]+((\.[[:xdigit:]]*)?[pP][+-]?[[:xdigit:]]+|\.[[:xdigit:]]*)"> => {
		if !s.contains('.') {
			parse_hexf32(&s.replace("p", ".p"), true).unwrap()
		} else {
			parse_hexf32(s, true).unwrap()
		}
	}
};

float64: f64 = {
	"-inf" => f64::NEG_INFINITY,
	r"\+?inf" => f64::INFINITY,
	<sign:r"[+-]"?> "nan:" <p:r"0x[[:xdigit:]]+"> => {
		let z = f64::from_bits(f64::INFINITY.to_bits() | u64::from_str_radix(&p[2..], 16).unwrap());
		if let Some("-") = sign { -z } else { z }
	},
	<s:r"[+-]?0x[[:xdigit:]]+((\.[[:xdigit:]]*)?[pP][+-]?[[:xdigit:]]+|\.[[:xdigit:]]*)"> => {
		if !s.contains('.') {
			parse_hexf64(&s.replace("p", ".p"), true).unwrap()
		} else {
			parse_hexf64(s, true).unwrap()
		}
	}
};

string: String = {
	r#""""# => String::new(),
	<s:r#""([^"\\]|\\([tnr\\"]|u\{[[:xdigit:]]+\}))+""#> => unescape(&s[1..s.len()-1]),
};

bytestring: Vec<u8> = {
	r#""""# => Vec::new(),
	<s:r#""(\\[[:xdigit:]]{2})+""#> => {
		let ascii_to_byte = |v| { char::from(v).to_digit(16).unwrap() as u8 };
		s[1..s.len()-1].as_bytes().chunks(3).map(|c| 16 * ascii_to_byte(c[1]) + ascii_to_byte(c[2])).collect()
	}
};
